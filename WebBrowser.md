# 웹 브라우저의 객체

## 1. Host Object

- JS **`실행환경에`** 정의된 **객체를** 말한다.
- JS 프로그램은 `웹 브라우저에 구현된 다양한 호스트 객체를 이용해` CSS로 스타일을 제어하거나 HTML 문서를 **제어할 수 있다.**
- 웹 브라우저의 **Window 객체를 제어할 수 있다.**
- 또한 대화형(Interactive) 웹 페이지 동적(Dynamic)으로 만들 수 있다. * (WEB IDL)과 호환
    1. 웹 페이지의 Document 객체 제어 (HTML 요소와 CSS 스타일 작업)
    2. 웹 페이지의 Window 객체 제어 및 브라우저 제어
    3. 웹 페이지에서 발생하는 이벤트 처리
    4. HTTP를 이용한 통신 제어

## 2. WEB Browser

웹 브라우저는 다음과 같은 기능을 제공한다.

- 파일 읽기와 쓰기
- 데이터베이스 기능
- 비동기 통신
- 2차원,3차원 컴퓨터 그래픽스 기능
- 키보드로 입력
- 마우스로 드래그 앤 드롭
- 멀티스레딩

## 3. Code Injection

- script 요소의 내용물로 작성하기(인라인 스크립트)

```HTML
    <script>
        console.log("What??!!");
    </script>
```

- 외부 파일 읽어 들어오기(외부 스크립트)

```HTML
    <script src=""../../anything.js"></script>
```

- 이벤트 처리기 속성에 작성하기

```HTML
    <input type="button" onclick="console.log("Nope!");"/>
```

- JS: URL(JS 의사 프로토콜)

```HTML
    <a href="javascript:console.log("Nope!");"></a>
```

**`Unobtrusive JavaScript를 위해`**  JS Code삽입을 가급적 안 쓰는게 좋다. (외부 스크립트 권장)

## 4. WEB Browser 렌더링 엔진

- **웹 브라우저의 동작을** 알아야 이벤트 타이밍에 맞게 JS문을 실행을 할 수 있다.
  - `Naver D2의` 글이 제일 잘 설명 되어 링크를 남긴다. <https://d2.naver.com/helloworld/59361>(2012년 글)
  - 내부적으로(브라우저) 파일을 분석해서 어떤 식으로 뷰(View)로 보여주는지 자세히 설명을 해준다.
- 웹 브라우저에서 `HTML 문서를 분석하고 표시한는 프로그램을` 가리켜 **`렌더링 엔진이라고 한다.`**
- `렌더링 엔진은 다음과 같은 처리 과정을 거쳐` HTML 문서의 구문을 분석하고 DOM 트리를 구축한 후에 HTML 안에 지정된 JS 코드를 실행한다.

1. 웹 브라우저로 웹 페이지를 열면 가장 먼저 **Window 객체가 생성된다.**
    - Window 객체는 웹 페이지의 `전역 객체로` 웹 페이지와 탭마다 생성된다.

2. **Document 객체가** `Window 객체의 포로퍼티로` 생성되며 렌더링 엔진이 `웹 페이지를 해석해서` **DOM 트리의 구축을 시도한다.**
    - Documet 객체는 **readyState 프로퍼티를 가지고 있으며,** 이 프로퍼티에는 `HTML 문서의 해석 상태를` 뜻하는 문자열이 저장된다.
    - readyState 프로퍼티의 `초깃값은 "loading" 문잘열이다.`

3. **HTML 문서는** HTML 구문을 작성 순서에 따라 `분석하면` **Document 객체 요소와** **텍스트 노드를** 추가해 나간다.

4. `HTML 문서 안에` **script 요소가 있으면** script 요소 안의 `코드 또는 외부 파일에 저장된 코드의 구문을 분석한다.`
    - 그 결과 오류가 발생하지 않으면 **그 시점에 코드를 실행한다.**
    - 이 때 script 요소는 **동기적으로 실행된다.**
    - 즉, script 요소의 구문을 분석해서 `실행할 때는` **HTML 문서의 구문 분석이 일시적으로 막히고,** JS 코드의 실행을 `완료한 후에는` 일시적으로 막혀 있었던 **HTML 문서의 구문 분석을 재개 한다.**

5. HTML 문서의 모든 내용을 읽은 후에 `DOM 트리 구축을 완료하면` **document.readyState 프로퍼티 값이 "interactive"로 바뀐다.**
    - 웹 브라우저는 `Document 객체에` DOM 트리 구축 완료를 알리기 위해 **DOMContentLoaded 이벤트를 발생한다.**

6. img 등의 요소가 `이미지 파일 등의 외부 리소스를 읽어 들여야 한다면` **이 시점에 읽어 들인다.**

7. `모든 리소스를 읽어 들인 후에는` **document.readyState 프로퍼티 값이 "complete"로 바뀐다.**
    - 마지막으로 `웹 브라우저는` `Window객체를 상대로` **load 이벤트를 발생한다.**

8. 이 시점부터 `다양한 이벤트(사용자 정의 이벤트, 네트워크 이벤트)를 수신하며,` `이벤트가 발생하면` 이벤트 처리가 **비동기로 호출된다.**

## 5. async와 defer

- HTML5부터 추가된 속성이다. 
- 둘 다 src 속성을 가진 script 요소에는 적용할 수 있지만 **인라인 스크립트에는 사용할 수 없다.**
- script 요소에 `async` 속성을 설정하면 script 요소의 코드가 **비동기적으로 실행된다.** 
  - HTML 문서의 구문 분석 처리를 막지 않으며 **script 요소의 코드를 최대한 빨리 실행한다.**
  - 하지만 순서가 보장되지 않아 읽어 들이는 순서에 의존하는 script 요소에는 async 속성을 설정하지 말아야 한다.
- `defer` 속성을 설정한 script 요소는 **DOM 트리 구축이 끝난 후에 실행이 된다.**
  - DOMContentLoaded 이벤트의 대안으로 활요할 수 있다.
- script 요소에 **`document.write 메서드가`** 있으면 `async와 defer 속성이 무시되어` **동기적으로 실행이 된다.** 
- async와 defer 속성을 지원하지 않는 웹 브라우저도 script 요소를 동기적으로 실행한다.

## 6. CSS와 렌더링

1. style 요소 안에 작성된 CSS 코드와 link 요소로 읽어 들인 CSS코드를 CSS 파서가 분석된다.
   - 구문 분석이 끝난 CSS 코드는 스타일 규칙으로 만들어진다.

2. HTML 코드로 만들어진 DOM 트리와 스타일 규칙을 바탕으로 렌더 트리라는 또 다른 트리를 만든다.
   - 렌더 트리에는 표시해야 하는 요소만 저장되며, 렌더 트리에 저장된 요소에는 스타일 정보를 추가한다.

3. 렌더 트리가 만들어진 후에는 DOM의 각 노드 위치와 크기를 결정한다.

4. 마지막으로 DOM의 각 노드를 렌더 트리의 스타일 정보를 바탕으로 그린다. 

- 앞의 과정은 HTML 문서를 다 읽어 들인 후에 실행되지 않고 HTML 문서를 읽어 들인는 과정에서 단계적으로 실행된다.
- `렌더링 엔진은` 사용자가 쾌적하게 사용할 수 있도록 콘텐츠를 최대한 빨리 화면에 표시하려고 한다.
- 일부 콘텐츠의 해석이 끝나면 곧바록 그것을 표시하고, 그 사이에 네트워크로 나머지 콘텐츠를 받아서 처리해 나간다.
- 이 `렌더 트리를 구축해서 배치하고 그리는 과정은` **처음 리소스를 읽어 들일 때, JS로 동적인 처리를 할 때, 사용자의 조작으로 HTML/CSS 코드가 바뀔 때마다 실행이 된다.**

## 7. URL 인코딩

```js
    encodeURI() // 영문, 숫자, 예약문자(;,/,?,:,@,&,=,+,$), 이스케이프 하지 않은 기호(-,_,!,~,*,(,),')는 인코딩을 하지 않는다.
    encodeURIComponent() // 영문, 숫자, 예약문자(;,/,?,:,@,&,=,+,$), 이스케이프 하지 않은 기호(-,_,!,~,*,(,),')까지 인코딩 한다.
    decodeURI()
    decodeURIComponent()
```